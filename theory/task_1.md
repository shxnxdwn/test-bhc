## Задание 1

Здесь мы проходимся циклом по массиву `arr` и на каждой итерации добавляем в очередь `setTimeout` с таймаутом 3000 мс. В setTimeout мы передаем анонимную функцию, которая проверяет:

* Если текущий элемент массива больше 13, то законсолить шаблонную строку `Good: текущий элемент`

* Во всех остальных случаях законсолить шаблонную строку `Bad: текущий элемент`

Соответственно, если запустить данный код, то сразу ничего не произойдет. Отработает цикл, на каждой итерации которого будет выполнен `setTimeout`, который является WebAPI. Так как в массиве `arr` 4 элемента, будет запланировано 4 вызова. Каждый из них по прошествии 3000 мс отдаст переданную анонимную функцию в очередь макрозадач, откуда она сразу же попадет в стек вызовов и будет выполнена.

При выполнении данных анонимных функций мы получим в консоль 4 раза `Bad: undefined`. Проблема данного кода в том, что когда выполняется функция, переданная `setTimeout`, то `i = 4` для всех вызовов, так как мы используем `var`, который имеет функциональную область видимости. То есть, такая область видимости не ограничивается блоком кода с циклом, как в данном случае. В итоге, для всех вызовов значение `i` будет `4`, так как мы увеличиваем `i` на последней итерации и потом уже проверка в цикле не проходит, а элемента с индексом `4` в нашем массиве нет, поэтому мы получаем `undefined`.

---

#### Чтобы исправить эту ошибку и код работал как задумано, нужно:

### Вариант 1

* Заменить var на let. Уже после этого все будет работать, так как переменные, объявленные с помощью инструкции `let` имеют блочную область видимости. На каждой итерации цикла будет создана своя переменная `i`, которую через замыкание (специальное внутреннее свойство `[[Enviroment]]`) запомнит анонимная функция, переданная в `setTimeout`. В результате, когда сработает таймер, мы получим то значение `i`, которое было в момент создания функции.

* Можно так же заменить function declaration на анонимную стрелочную функцию, так как здесь нет необходимости использовать возможности, которые предоставляет синтаксис function declaration.

* Можно заменить обычный цикл на for..of, но это крайне спорно и ничего, в общем-то, не дает, кроме субъективно лучшей читаемости. Так же можно изменить название массива, чтобы более конкретно описать то, что в нем находится.

Итоговый код:

```
const numbers = [10, 12, 15, 21];

for (let number of numbers) {
    setTimeout(() => {
        console.log(number > 13 ? `Good: ${number}` : `Bad: ${number}`)
    }, 3000);
}
```



### Вариант 2

Можно решить данную задачу с помощью метода `forEach`. Здесь мы делаем то же самое, что и в цикле.

Итоговый код:

```
const numbers = [10, 12, 15, 21];

numbers.forEach((number) => {
    setTimeout(() => {
        console.log(number > 13 ? `Good: ${number}` : `Bad: ${number}`);
    }, 3000);
});
```

---

Для любителей Codewars можно сократить до одной строки, но я так никогда не пишу

```
arr.forEach(n => setTimeout(() => console.log(n > 13 ? `Good: ${n}` : `Bad: ${n}`), 3000));
```
